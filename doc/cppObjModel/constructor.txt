* 如果程序员没有定义任何构造函数，那么会有一个隐式的默认构造函数定义出来，注意这个隐式的构造函数是无用的（trivial）,它不会帮你初始化成员
* global objects 的内存保证会在程序启动时候被清 0；local objects 在堆或栈中，不会被清 0，而是上一次内存使用后的值
* 编译器在以下4种情况下会合成一个有用的默认构造函数（注：有用是指对编译器有用，非程序员）
  成员有 default constructor 时
  基类有 default constructor 时
  有 virtual functions 时
  有 virtual base class 时
  注：不属于上述 4 种情况，且没有显式声明任何 constructor 的类，只能说它拥有 隐式无用的
     默认构造函数（implicit trivial default constructor），实际上并不会被合成出来
  注：在合成的 default constructor 中，只有 base class subobjects 和 member class objects 会被初始化，
     其他非静态成员（如int，指针）都不会被初始化
* 有 3 种情况会触发 copy 操作
  当一个对象以值传递的方式传入函数时。如：void func(X x) { }
  当一个对象以值传递的方式从函数返回时。如：X getObj() { X x; return x; }
  当一个对象需要通过另一个对象进行初始化时。如 X x = xx; 或 X x(xx)
* 有 4 种情况不能够被位逐次拷贝（Bitwise Copy Semantics）
  类有 copy constructor 时（不论是显式声明的还是编译器合成的）
  基类有 copy constructor 时
  有 virtual functions 时
  有 virtual base class 时
* 如果类声明了 virtual function，那么在编译期间，编译器会为类增加 2 件东西：
  一张 vtbl(virtual function table)。注：vtbl 只有一份
  为每一个类的 object 增加一个 vtbl 指针
