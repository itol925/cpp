#include <iostream>

namespace stl {
    namespace segment {
        // * c++ 包含哪些段
        // 1：栈。存放函数局部变量、参数和返回值
        // 2：堆。存放动态数据，如 new 出来的变量
        // 3：BSS 段（Block Started by Symbol）。存放未初始化的数据
        // 4：数据段。存放初始化完成的数据。如静态变量和全局变量
        // 5：代码段。存储代码指令
        // 注：为什么需要分 BSS 段和数据段，而不是将合并在一起？因为系统需要清楚地知道每个字段是否初始化，如果没有初始化，系统默认会赋 0 值，如
        // 果二者混一起，那么系统需要额外地保存每个字段是否初始化的状态，增加了系统的负担

        // * c++ 可执行文件的内存布局一般是怎么样的
        /* 以下是 Linux 系统中一个可执行文件的典型布局：
         * +------------------+
         * |       Stack      |
         * +------------------+
         * |        ...       |
         * +------------------+
         * |       Heap       |
         * +------------------+
         * |       BSS        |
         * +------------------+
         * |       Data       |
         * +------------------+
         * |       Text       |
         * +------------------｜
         * */
        // 上图中：
        // 1：栈位于内存的顶部，向下增长；
        // 2：堆位于栈的下方，向上增长；
        // 3：BSS 段位于堆的下方；
        // 4：数据段位于 BSS 段的下方；
        // 5：代码段位于数据段的下方

        // * 程序执行过程
        // 当程序启动时，系统会将程序的 代码段、数据段 和 BSS段 加载到内存中
        // 当程序开始执行时，系统初始化一个栈，用于存储函数的参数、局部变量和返回值；初始化一块堆内存（大小可调节），用于动态分配。
        // 当调用一个函数时，便会创建一个新的栈帧压入栈中，函数返回时，栈帧弹出并销毁。
        // 程序执行过程中，cpu 会从 代码段 中读取指令并执行它们，执行过程中，cpu 指针可能会访问 数据段、BSS段、栈 和 堆上的数据
        // 程序结束时，系统会释放程序所占用的所有资源，包括 栈、堆以及代码段、数据段和 BSS 段所占用的内存。
        // 注：栈帧保存了函数的参数、返回值地址、局部变量、保存的寄存器的值。每一次函数调用都会创建一个栈帧。
        // 注：程序结束后，堆上的内存也是会被释放的，操作系统回收的是整个进程的内存空间。

        namespace demo {
            using namespace std;
            int global_var = 42;    // 数据段
            int global_uninit;      // BSS 段

            int test() {
                int local_var = 0;              // 栈
                int *dynamic_var = new int(88); // 堆
                delete dynamic_var;
                return 0;
            }
        }
    }
}